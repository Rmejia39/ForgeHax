package dev.fiki.forgehax.main.mods.exploit;

import com.google.common.collect.Sets;
import dev.fiki.forgehax.api.asm.MapClass;
import dev.fiki.forgehax.api.asm.MapField;
import dev.fiki.forgehax.api.cmd.argument.Arguments;
import dev.fiki.forgehax.api.cmd.flag.EnumFlag;
import dev.fiki.forgehax.api.cmd.settings.collections.SimpleSettingSet;
import dev.fiki.forgehax.api.mod.Category;
import dev.fiki.forgehax.api.mod.ToggleMod;
import dev.fiki.forgehax.api.modloader.RegisterMod;
import dev.fiki.forgehax.api.reflection.types.ReflectionClass;
import dev.fiki.forgehax.api.reflection.types.ReflectionField;
import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
import it.unimi.dsi.fastutil.shorts.Short2ObjectArrayMap;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import net.minecraft.network.PacketBuffer;
import net.minecraftforge.fml.network.FMLHandshakeMessages;
import net.minecraftforge.fml.network.FMLNetworkConstants;
import net.minecraftforge.fml.network.NetworkDirection;
import net.minecraftforge.fml.network.NetworkEvent;
import net.minecraftforge.fml.network.simple.IndexedMessageCodec;
import net.minecraftforge.fml.network.simple.SimpleChannel;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * The jenkins server won't include this class in its artifacts
 */

@RegisterMod(
    name = "ForgeModListSpoofer",
    description = "Hide mods from forge handshake",
    category = Category.EXPLOIT,
    flags = EnumFlag.HIDDEN
)
@RequiredArgsConstructor
public class ForgeModListSpoofer extends ToggleMod {
  private final SimpleSettingSet<String> spoofing = newSimpleSettingSet(String.class)
      .name("spoofing")
      .description("List of mods to remove from forges modlist handshake packet")
      .argument(Arguments.newStringArgument()
          .label("modid")
          .build())
      .supplier(Sets::newHashSet)
      .defaultsTo("forgehax")
      .build();

  @MapClass(classType = IndexedMessageCodec.class, innerClassName = "MessageHandler")
  private final ReflectionClass<?> IndexedMessageCodec$MessageHandler;

  @MapField(parentClass = IndexedMessageCodec.class, name = "indicies")
  private final ReflectionField<Short2ObjectArrayMap<Object>> IndexedMessageCodec_indicies;
  @MapField(parentClass = IndexedMessageCodec.class, name = "types")
  private final ReflectionField<Object2ObjectArrayMap<Class<?>, Object>> IndexedMessageCodec_types;

  @MapField(parentClass = FMLNetworkConstants.class, name = "handshakeChannel")
  private final ReflectionField<SimpleChannel> FMLNetworkConstants_handshakeChannel;

  @MapField(parentClass = SimpleChannel.class, name = "indexedCodec")
  private final ReflectionField<IndexedMessageCodec> SimpleChannel_indexedCodec;

  @MapField(
      parent = @MapClass(classType = IndexedMessageCodec.class, innerClassName = "MessageHandler"),
      name = "loginIndexSetter"
  )
  private final ReflectionField<Optional<BiConsumer<Object, Integer>>> IndexedMessageCodec$MessageHandler_loginIndexSetter;
  @MapField(
      parent = @MapClass(classType = IndexedMessageCodec.class, innerClassName = "MessageHandler"),
      name = "loginIndexGetter"
  )
  private final ReflectionField<Optional<Function<Object, Integer>>> IndexedMessageCodec$MessageHandler_loginIndexGetter;

  private Object oldMessageHandler = null;
  private short handlerIndex = 0;

  private IndexedMessageCodec getCodec() {
    SimpleChannel handshakeChannel = Objects.requireNonNull(FMLNetworkConstants_handshakeChannel.getStatic(),
        "Could not find handshake channel");
    return Objects.requireNonNull(SimpleChannel_indexedCodec.get(handshakeChannel), "Channel Codec is null");
  }

  @SneakyThrows
  @Override
  protected void onEnabled() {
    // get channel codec
    IndexedMessageCodec codec = getCodec();

    final Class<?> type = FMLHandshakeMessages.C2SModListReply.class;

    // get handler by class type
    Object handler = IndexedMessageCodec_types.get(codec).get(type);
    Objects.requireNonNull(handler, "Could not find MessageHandler for S2CModList type");

    // keep the old handler
    oldMessageHandler = handler;

    // create new message handler
    Constructor<?> constructor = IndexedMessageCodec$MessageHandler.get()
        .getDeclaredConstructor(IndexedMessageCodec.class, int.class,
            Class.class, BiConsumer.class, Function.class, BiConsumer.class, Optional.class);
    constructor.setAccessible(true);

    int index = lookupField("index", handler);
    Class<?> messageType = lookupField("messageType", handler);
    Optional<BiConsumer<Object, PacketBuffer>> encoder = lookupField("encoder", handler);
    Optional<Function<PacketBuffer, Object>> decoder = lookupField("decoder", handler);
    BiConsumer<Object, Supplier<NetworkEvent.Context>> messageConsumer = lookupField("messageConsumer", handler);
    Optional<NetworkDirection> networkDirection = lookupField("networkDirection", handler);

    handlerIndex = (short) (index & 0xFF);

    // remove old handler from maps
    IndexedMessageCodec_indicies.get(codec).remove(handlerIndex);
    IndexedMessageCodec_types.get(codec).remove(type);

    // create new encoder that removes the mod
    BiConsumer<Object, PacketBuffer> overrideEncoder = (o, buffer) -> {
      if (o instanceof FMLHandshakeMessages.C2SModListReply) {
        FMLHandshakeMessages.C2SModListReply instance = (FMLHandshakeMessages.C2SModListReply) o;
        instance.getModList().removeAll(spoofing);
      } else {
        log.error("Encoder is trying to encode object that isn't S2CModList");
      }

      if (encoder != null) {
        encoder.ifPresent(c -> c.accept(o, buffer));
      }
    };

    // create message handler with our own encoder
    Object instance = constructor.newInstance(codec, index, type,
        overrideEncoder, decoder.get(), messageConsumer, networkDirection);

    // set the new MessageHandler's loginIndexSetter/Getter
    IndexedMessageCodec$MessageHandler_loginIndexSetter
        .set(instance, lookupField("loginIndexSetter", handler));
    IndexedMessageCodec$MessageHandler_loginIndexGetter
        .set(instance, lookupField("loginIndexGetter", handler));

    // the encoder should now be redirected to our custom encoder
  }

  @Override
  protected void onDisabled() {
    Objects.requireNonNull(oldMessageHandler, "Old message handler is null");

    // get channel codec
    IndexedMessageCodec codec = getCodec();

    // remove custom handler from maps
    IndexedMessageCodec_indicies.get(codec).remove(handlerIndex);
    IndexedMessageCodec_types.get(codec).remove(FMLHandshakeMessages.C2SModListReply.class);

    // add back old handler
    IndexedMessageCodec_indicies.get(codec).put(handlerIndex, oldMessageHandler);
    IndexedMessageCodec_types.get(codec).put(FMLHandshakeMessages.C2SModListReply.class, oldMessageHandler);

    // yeet
    oldMessageHandler = null;
  }

  @SneakyThrows
  private static <T> T lookupField(String fieldName, Object instance) {
    for (Field field : instance.getClass().getDeclaredFields()) {
      if (field.getName().equals(fieldName)) {
        field.setAccessible(true);
        return (T) field.get(instance);
      }
    }
    return null;
  }
}
